// Code generated by Participle. DO NOT EDIT.
package parse

import (
	"fmt"
	"io"
	"regexp/syntax"
	"strings"
	"sync"
	"unicode/utf8"

	"github.com/alecthomas/participle/v2"
	"github.com/alecthomas/participle/v2/lexer"
)

var _ syntax.Op
var _ fmt.State

const _ = utf8.RuneError

var ConfigBackRefCache sync.Map
var ConfigLexer lexer.Definition = lexerConfigDefinitionImpl{}

type lexerConfigDefinitionImpl struct{}

func (lexerConfigDefinitionImpl) Symbols() map[string]lexer.TokenType {
	return map[string]lexer.TokenType{
		"CC":             -3,
		"CO":             -7,
		"EOF":            -1,
		"EX":             -28,
		"FS":             -15,
		"ID":             -26,
		"NS":             -20,
		"NU":             -17,
		"OP":             -27,
		"PC":             -14,
		"PO":             -8,
		"QQ":             -16,
		"RS":             -25,
		"SC":             -24,
		"SO":             -23,
		"XS":             -22,
		"returnToParent": -10,
	}
}

func (lexerConfigDefinitionImpl) LexString(filename string, s string) (lexer.Lexer, error) {
	return &lexerConfigImpl{
		s: s,
		pos: lexer.Position{
			Filename: filename,
			Line:     1,
			Column:   1,
		},
		states: []lexerConfigState{{name: "Root"}},
	}, nil
}

func (d lexerConfigDefinitionImpl) LexBytes(filename string, b []byte) (lexer.Lexer, error) {
	return d.LexString(filename, string(b))
}

func (d lexerConfigDefinitionImpl) Lex(filename string, r io.Reader) (lexer.Lexer, error) {
	s := &strings.Builder{}
	_, err := io.Copy(s, r)
	if err != nil {
		return nil, err
	}
	return d.LexString(filename, s.String())
}

type lexerConfigState struct {
	name   string
	groups []string
}

type lexerConfigImpl struct {
	s      string
	p      int
	pos    lexer.Position
	states []lexerConfigState
}

func (l *lexerConfigImpl) Next() (lexer.Token, error) {
	if l.p == len(l.s) {
		return lexer.EOFToken(l.pos), nil
	}
	var (
		state  = l.states[len(l.states)-1]
		groups []int
		sym    lexer.TokenType
	)
	switch state.name {
	case "Composite":
		if match := matchConfigXS(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = -22
			groups = match[:]
		} else if match := matchConfigCC(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = -3
			groups = match[:]
			l.states = l.states[:len(l.states)-1]
		} else if match := matchConfigFS(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = -15
			groups = match[:]
		} else if match := matchConfigNS(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = -20
			groups = match[:]
		}
	case "Definition":
		if match := matchConfigXS(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = -22
			groups = match[:]
		} else if match := matchConfigCO(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = -7
			groups = match[:]
			l.states = append(l.states, lexerConfigState{name: "Composite"})
		} else if match := matchConfigPO(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = -8
			groups = match[:]
			l.states = append(l.states, lexerConfigState{name: "Parameter"})
		} else if match := matchConfigSO(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = -23
			groups = match[:]
			l.states = append(l.states, lexerConfigState{name: "Statement"})
		} else if true {
			l.states = l.states[:len(l.states)-1]
			return l.Next()
		}
	case "Global":
		if match := matchConfigXS(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = -22
			groups = match[:]
		}
	case "Ignore":
		if match := matchConfigRS(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = -25
			groups = match[:]
		}
	case "Parameter":
		if match := matchConfigXS(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = -22
			groups = match[:]
		} else if match := matchConfigPC(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = -14
			groups = match[:]
			l.states = l.states[:len(l.states)-1]
		} else if match := matchConfigFS(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = -15
			groups = match[:]
		} else if match := matchConfigQQ(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = -16
			groups = match[:]
		} else if match := matchConfigNU(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = -17
			groups = match[:]
		} else if match := matchConfigID(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = -26
			groups = match[:]
		}
	case "Root":
		if match := matchConfigXS(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = -22
			groups = match[:]
		} else if match := matchConfigNS(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = -20
			groups = match[:]
			l.states = append(l.states, lexerConfigState{name: "Definition"})
		} else if match := matchConfigRS(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = -25
			groups = match[:]
		}
	case "Statement":
		if match := matchConfigXS(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = -22
			groups = match[:]
		} else if match := matchConfigSO(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = -23
			groups = match[:]
			l.states = append(l.states, lexerConfigState{name: "Statement"})
		} else if match := matchConfigSC(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = -24
			groups = match[:]
			l.states = l.states[:len(l.states)-1]
		} else if match := matchConfigRS(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = -25
			groups = match[:]
		} else if match := matchConfigID(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = -26
			groups = match[:]
		} else if match := matchConfigOP(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = -27
			groups = match[:]
		} else if match := matchConfigEX(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = -28
			groups = match[:]
		}
	}
	if groups == nil {
		sample := []rune(l.s[l.p:])
		if len(sample) > 16 {
			sample = append(sample[:16], []rune("...")...)
		}
		return lexer.Token{}, participle.Errorf(l.pos, "invalid input text %q", string(sample))
	}
	pos := l.pos
	span := l.s[groups[0]:groups[1]]
	l.p = groups[1]
	l.pos.Advance(span)
	return lexer.Token{
		Type:  sym,
		Value: span,
		Pos:   pos,
	}, nil
}

func (l *lexerConfigImpl) sgroups(match []int) []string {
	sgroups := make([]string, len(match)/2)
	for i := 0; i < len(match)-1; i += 2 {
		sgroups[i/2] = l.s[l.p+match[i] : l.p+match[i+1]]
	}
	return sgroups
}

// /\*(?:[^\*]|\*[^/])*\*/|(?://|#)[^\n\r]*\r?\n|[\t\n\f\r ]+
func matchConfigXS(s string, p int, backrefs []string) (groups [2]int) {
	// /\* (Literal)
	l0 := func(s string, p int) int {
		if p+2 <= len(s) && s[p:p+2] == "/*" {
			return p + 2
		}
		return -1
	}
	// [^\*] (CharClass)
	l1 := func(s string, p int) int {
		if len(s) <= p {
			return -1
		}
		var (
			rn rune
			n  int
		)
		if s[p] < utf8.RuneSelf {
			rn, n = rune(s[p]), 1
		} else {
			rn, n = utf8.DecodeRuneInString(s[p:])
		}
		switch {
		case rn >= '\x00' && rn <= ')':
			return p + 1
		case rn >= '+' && rn <= '\U0010ffff':
			return p + n
		}
		return -1
	}
	// \* (Literal)
	l2 := func(s string, p int) int {
		if p < len(s) && s[p] == '*' {
			return p + 1
		}
		return -1
	}
	// [^/] (CharClass)
	l3 := func(s string, p int) int {
		if len(s) <= p {
			return -1
		}
		var (
			rn rune
			n  int
		)
		if s[p] < utf8.RuneSelf {
			rn, n = rune(s[p]), 1
		} else {
			rn, n = utf8.DecodeRuneInString(s[p:])
		}
		switch {
		case rn >= '\x00' && rn <= '.':
			return p + 1
		case rn >= '0' && rn <= '\U0010ffff':
			return p + n
		}
		return -1
	}
	// \*[^/] (Concat)
	l4 := func(s string, p int) int {
		if p = l2(s, p); p == -1 {
			return -1
		}
		if p = l3(s, p); p == -1 {
			return -1
		}
		return p
	}
	// [^\*]|\*[^/] (Alternate)
	l5 := func(s string, p int) int {
		if np := l1(s, p); np != -1 {
			return np
		}
		if np := l4(s, p); np != -1 {
			return np
		}
		return -1
	}
	// (?:[^\*]|\*[^/])* (Star)
	l6 := func(s string, p int) int {
		for len(s) > p {
			if np := l5(s, p); np == -1 {
				return p
			} else {
				p = np
			}
		}
		return p
	}
	// \*/ (Literal)
	l7 := func(s string, p int) int {
		if p+2 <= len(s) && s[p:p+2] == "*/" {
			return p + 2
		}
		return -1
	}
	// /\*(?:[^\*]|\*[^/])*\*/ (Concat)
	l8 := func(s string, p int) int {
		if p = l0(s, p); p == -1 {
			return -1
		}
		if p = l6(s, p); p == -1 {
			return -1
		}
		if p = l7(s, p); p == -1 {
			return -1
		}
		return p
	}
	// // (Literal)
	l9 := func(s string, p int) int {
		if p+2 <= len(s) && s[p:p+2] == "//" {
			return p + 2
		}
		return -1
	}
	// # (Literal)
	l10 := func(s string, p int) int {
		if p < len(s) && s[p] == '#' {
			return p + 1
		}
		return -1
	}
	// //|# (Alternate)
	l11 := func(s string, p int) int {
		if np := l9(s, p); np != -1 {
			return np
		}
		if np := l10(s, p); np != -1 {
			return np
		}
		return -1
	}
	// [^\n\r] (CharClass)
	l12 := func(s string, p int) int {
		if len(s) <= p {
			return -1
		}
		var (
			rn rune
			n  int
		)
		if s[p] < utf8.RuneSelf {
			rn, n = rune(s[p]), 1
		} else {
			rn, n = utf8.DecodeRuneInString(s[p:])
		}
		switch {
		case rn >= '\x00' && rn <= '\t':
			return p + 1
		case rn >= '\v' && rn <= '\f':
			return p + 1
		case rn >= '\x0e' && rn <= '\U0010ffff':
			return p + n
		}
		return -1
	}
	// [^\n\r]* (Star)
	l13 := func(s string, p int) int {
		for len(s) > p {
			if np := l12(s, p); np == -1 {
				return p
			} else {
				p = np
			}
		}
		return p
	}
	// \r (Literal)
	l14 := func(s string, p int) int {
		if p < len(s) && s[p] == '\r' {
			return p + 1
		}
		return -1
	}
	// \r? (Quest)
	l15 := func(s string, p int) int {
		if np := l14(s, p); np != -1 {
			return np
		}
		return p
	}
	// \n (Literal)
	l16 := func(s string, p int) int {
		if p < len(s) && s[p] == '\n' {
			return p + 1
		}
		return -1
	}
	// (?://|#)[^\n\r]*\r?\n (Concat)
	l17 := func(s string, p int) int {
		if p = l11(s, p); p == -1 {
			return -1
		}
		if p = l13(s, p); p == -1 {
			return -1
		}
		if p = l15(s, p); p == -1 {
			return -1
		}
		if p = l16(s, p); p == -1 {
			return -1
		}
		return p
	}
	// [\t\n\f\r ] (CharClass)
	l18 := func(s string, p int) int {
		if len(s) <= p {
			return -1
		}
		rn := s[p]
		switch {
		case rn >= '\t' && rn <= '\n':
			return p + 1
		case rn >= '\f' && rn <= '\r':
			return p + 1
		case rn == ' ':
			return p + 1
		}
		return -1
	}
	// [\t\n\f\r ]+ (Plus)
	l19 := func(s string, p int) int {
		if p = l18(s, p); p == -1 {
			return -1
		}
		for len(s) > p {
			if np := l18(s, p); np == -1 {
				return p
			} else {
				p = np
			}
		}
		return p
	}
	// /\*(?:[^\*]|\*[^/])*\*/|(?://|#)[^\n\r]*\r?\n|[\t\n\f\r ]+ (Alternate)
	l20 := func(s string, p int) int {
		if np := l8(s, p); np != -1 {
			return np
		}
		if np := l17(s, p); np != -1 {
			return np
		}
		if np := l19(s, p); np != -1 {
			return np
		}
		return -1
	}
	np := l20(s, p)
	if np == -1 {
		return
	}
	groups[0] = p
	groups[1] = np
	return
}

// >
func matchConfigCC(s string, p int, backrefs []string) (groups [2]int) {
	if p < len(s) && s[p] == '>' {
		groups[0] = p
		groups[1] = p + 1
	}
	return
}

// ,
func matchConfigFS(s string, p int, backrefs []string) (groups [2]int) {
	if p < len(s) && s[p] == ',' {
		groups[0] = p
		groups[1] = p + 1
	}
	return
}

// [^\t\n\f\r \(\),;->\[\]\{\}]+(?: +[^\t\n\f\r \(\),;->\[\]\{\}]+)*
func matchConfigNS(s string, p int, backrefs []string) (groups [2]int) {
	// [^\t\n\f\r \(\),;->\[\]\{\}] (CharClass)
	l0 := func(s string, p int) int {
		if len(s) <= p {
			return -1
		}
		var (
			rn rune
			n  int
		)
		if s[p] < utf8.RuneSelf {
			rn, n = rune(s[p]), 1
		} else {
			rn, n = utf8.DecodeRuneInString(s[p:])
		}
		switch {
		case rn >= '\x00' && rn <= '\b':
			return p + 1
		case rn == '\v':
			return p + 1
		case rn >= '\x0e' && rn <= '\x1f':
			return p + 1
		case rn >= '!' && rn <= '\'':
			return p + 1
		case rn >= '*' && rn <= '+':
			return p + 1
		case rn >= '-' && rn <= ':':
			return p + 1
		case rn >= '?' && rn <= 'Z':
			return p + 1
		case rn == '\\':
			return p + 1
		case rn >= '^' && rn <= 'z':
			return p + 1
		case rn == '|':
			return p + 1
		case rn >= '~' && rn <= '\U0010ffff':
			return p + n
		}
		return -1
	}
	// [^\t\n\f\r \(\),;->\[\]\{\}]+ (Plus)
	l1 := func(s string, p int) int {
		if p = l0(s, p); p == -1 {
			return -1
		}
		for len(s) > p {
			if np := l0(s, p); np == -1 {
				return p
			} else {
				p = np
			}
		}
		return p
	}
	// (Literal)
	l2 := func(s string, p int) int {
		if p < len(s) && s[p] == ' ' {
			return p + 1
		}
		return -1
	}
	// + (Plus)
	l3 := func(s string, p int) int {
		if p = l2(s, p); p == -1 {
			return -1
		}
		for len(s) > p {
			if np := l2(s, p); np == -1 {
				return p
			} else {
				p = np
			}
		}
		return p
	}
	// +[^\t\n\f\r \(\),;->\[\]\{\}]+ (Concat)
	l4 := func(s string, p int) int {
		if p = l3(s, p); p == -1 {
			return -1
		}
		if p = l1(s, p); p == -1 {
			return -1
		}
		return p
	}
	// (?: +[^\t\n\f\r \(\),;->\[\]\{\}]+)* (Star)
	l5 := func(s string, p int) int {
		for len(s) > p {
			if np := l4(s, p); np == -1 {
				return p
			} else {
				p = np
			}
		}
		return p
	}
	// [^\t\n\f\r \(\),;->\[\]\{\}]+(?: +[^\t\n\f\r \(\),;->\[\]\{\}]+)* (Concat)
	l6 := func(s string, p int) int {
		if p = l1(s, p); p == -1 {
			return -1
		}
		if p = l5(s, p); p == -1 {
			return -1
		}
		return p
	}
	np := l6(s, p)
	if np == -1 {
		return
	}
	groups[0] = p
	groups[1] = np
	return
}

// <
func matchConfigCO(s string, p int, backrefs []string) (groups [2]int) {
	if p < len(s) && s[p] == '<' {
		groups[0] = p
		groups[1] = p + 1
	}
	return
}

// \(
func matchConfigPO(s string, p int, backrefs []string) (groups [2]int) {
	if p < len(s) && s[p] == '(' {
		groups[0] = p
		groups[1] = p + 1
	}
	return
}

// \{
func matchConfigSO(s string, p int, backrefs []string) (groups [2]int) {
	if p < len(s) && s[p] == '{' {
		groups[0] = p
		groups[1] = p + 1
	}
	return
}

// (?:)
func matchConfigreturnToParent(s string, p int, backrefs []string) (groups [2]int) {
	// (?:) (EmptyMatch)
	l0 := func(s string, p int) int {
		if len(s) == 0 {
			return p
		}
		return -1
	}
	np := l0(s, p)
	if np == -1 {
		return
	}
	groups[0] = p
	groups[1] = np
	return
}

// ;
func matchConfigRS(s string, p int, backrefs []string) (groups [2]int) {
	if p < len(s) && s[p] == ';' {
		groups[0] = p
		groups[1] = p + 1
	}
	return
}

// \)
func matchConfigPC(s string, p int, backrefs []string) (groups [2]int) {
	if p < len(s) && s[p] == ')' {
		groups[0] = p
		groups[1] = p + 1
	}
	return
}

// (?-s:"(?:\\.|[^"])*")
func matchConfigQQ(s string, p int, backrefs []string) (groups [2]int) {
	// " (Literal)
	l0 := func(s string, p int) int {
		if p < len(s) && s[p] == '"' {
			return p + 1
		}
		return -1
	}
	// \\ (Literal)
	l1 := func(s string, p int) int {
		if p < len(s) && s[p] == '\\' {
			return p + 1
		}
		return -1
	}
	// (?-s:.) (AnyCharNotNL)
	l2 := func(s string, p int) int {
		var (
			rn rune
			n  int
		)
		if s[p] < utf8.RuneSelf {
			rn, n = rune(s[p]), 1
		} else {
			rn, n = utf8.DecodeRuneInString(s[p:])
		}
		if len(s) <= p+n || rn == '\n' {
			return -1
		}
		return p + n
	}
	// (?-s:\\.) (Concat)
	l3 := func(s string, p int) int {
		if p = l1(s, p); p == -1 {
			return -1
		}
		if p = l2(s, p); p == -1 {
			return -1
		}
		return p
	}
	// [^"] (CharClass)
	l4 := func(s string, p int) int {
		if len(s) <= p {
			return -1
		}
		var (
			rn rune
			n  int
		)
		if s[p] < utf8.RuneSelf {
			rn, n = rune(s[p]), 1
		} else {
			rn, n = utf8.DecodeRuneInString(s[p:])
		}
		switch {
		case rn >= '\x00' && rn <= '!':
			return p + 1
		case rn >= '#' && rn <= '\U0010ffff':
			return p + n
		}
		return -1
	}
	// (?-s:\\.|[^"]) (Alternate)
	l5 := func(s string, p int) int {
		if np := l3(s, p); np != -1 {
			return np
		}
		if np := l4(s, p); np != -1 {
			return np
		}
		return -1
	}
	// (?-s:(?:\\.|[^"])*) (Star)
	l6 := func(s string, p int) int {
		for len(s) > p {
			if np := l5(s, p); np == -1 {
				return p
			} else {
				p = np
			}
		}
		return p
	}
	// (?-s:"(?:\\.|[^"])*") (Concat)
	l7 := func(s string, p int) int {
		if p = l0(s, p); p == -1 {
			return -1
		}
		if p = l6(s, p); p == -1 {
			return -1
		}
		if p = l0(s, p); p == -1 {
			return -1
		}
		return p
	}
	np := l7(s, p)
	if np == -1 {
		return
	}
	groups[0] = p
	groups[1] = np
	return
}

// [\+\-]?(?:(?:[0\\]x|\$)[0-9A-Fa-f]+|0(?:o?[0-7]+|b[01]+)|(?i:(?:[0-9]+\.?[0-9]*|\.[0-9]+)(?:E[\+\-]?[0-9]+)?))
func matchConfigNU(s string, p int, backrefs []string) (groups [2]int) {
	// [\+\-] (CharClass)
	l0 := func(s string, p int) int {
		if len(s) <= p {
			return -1
		}
		rn := s[p]
		if rn == '+' || rn == '-' {
			return p + 1
		}
		return -1
	}
	// [\+\-]? (Quest)
	l1 := func(s string, p int) int {
		if np := l0(s, p); np != -1 {
			return np
		}
		return p
	}
	// [0\\] (CharClass)
	l2 := func(s string, p int) int {
		if len(s) <= p {
			return -1
		}
		rn := s[p]
		if rn == '0' || rn == '\\' {
			return p + 1
		}
		return -1
	}
	// x (Literal)
	l3 := func(s string, p int) int {
		if p < len(s) && s[p] == 'x' {
			return p + 1
		}
		return -1
	}
	// [0\\]x (Concat)
	l4 := func(s string, p int) int {
		if p = l2(s, p); p == -1 {
			return -1
		}
		if p = l3(s, p); p == -1 {
			return -1
		}
		return p
	}
	// \$ (Literal)
	l5 := func(s string, p int) int {
		if p < len(s) && s[p] == '$' {
			return p + 1
		}
		return -1
	}
	// [0\\]x|\$ (Alternate)
	l6 := func(s string, p int) int {
		if np := l4(s, p); np != -1 {
			return np
		}
		if np := l5(s, p); np != -1 {
			return np
		}
		return -1
	}
	// [0-9A-Fa-f] (CharClass)
	l7 := func(s string, p int) int {
		if len(s) <= p {
			return -1
		}
		rn := s[p]
		switch {
		case rn >= '0' && rn <= '9':
			return p + 1
		case rn >= 'A' && rn <= 'F':
			return p + 1
		case rn >= 'a' && rn <= 'f':
			return p + 1
		}
		return -1
	}
	// [0-9A-Fa-f]+ (Plus)
	l8 := func(s string, p int) int {
		if p = l7(s, p); p == -1 {
			return -1
		}
		for len(s) > p {
			if np := l7(s, p); np == -1 {
				return p
			} else {
				p = np
			}
		}
		return p
	}
	// (?:[0\\]x|\$)[0-9A-Fa-f]+ (Concat)
	l9 := func(s string, p int) int {
		if p = l6(s, p); p == -1 {
			return -1
		}
		if p = l8(s, p); p == -1 {
			return -1
		}
		return p
	}
	// 0 (Literal)
	l10 := func(s string, p int) int {
		if p < len(s) && s[p] == '0' {
			return p + 1
		}
		return -1
	}
	// o (Literal)
	l11 := func(s string, p int) int {
		if p < len(s) && s[p] == 'o' {
			return p + 1
		}
		return -1
	}
	// o? (Quest)
	l12 := func(s string, p int) int {
		if np := l11(s, p); np != -1 {
			return np
		}
		return p
	}
	// [0-7] (CharClass)
	l13 := func(s string, p int) int {
		if len(s) <= p {
			return -1
		}
		rn := s[p]
		switch {
		case rn >= '0' && rn <= '7':
			return p + 1
		}
		return -1
	}
	// [0-7]+ (Plus)
	l14 := func(s string, p int) int {
		if p = l13(s, p); p == -1 {
			return -1
		}
		for len(s) > p {
			if np := l13(s, p); np == -1 {
				return p
			} else {
				p = np
			}
		}
		return p
	}
	// o?[0-7]+ (Concat)
	l15 := func(s string, p int) int {
		if p = l12(s, p); p == -1 {
			return -1
		}
		if p = l14(s, p); p == -1 {
			return -1
		}
		return p
	}
	// b (Literal)
	l16 := func(s string, p int) int {
		if p < len(s) && s[p] == 'b' {
			return p + 1
		}
		return -1
	}
	// [01] (CharClass)
	l17 := func(s string, p int) int {
		if len(s) <= p {
			return -1
		}
		rn := s[p]
		switch {
		case rn >= '0' && rn <= '1':
			return p + 1
		}
		return -1
	}
	// [01]+ (Plus)
	l18 := func(s string, p int) int {
		if p = l17(s, p); p == -1 {
			return -1
		}
		for len(s) > p {
			if np := l17(s, p); np == -1 {
				return p
			} else {
				p = np
			}
		}
		return p
	}
	// b[01]+ (Concat)
	l19 := func(s string, p int) int {
		if p = l16(s, p); p == -1 {
			return -1
		}
		if p = l18(s, p); p == -1 {
			return -1
		}
		return p
	}
	// o?[0-7]+|b[01]+ (Alternate)
	l20 := func(s string, p int) int {
		if np := l15(s, p); np != -1 {
			return np
		}
		if np := l19(s, p); np != -1 {
			return np
		}
		return -1
	}
	// 0(?:o?[0-7]+|b[01]+) (Concat)
	l21 := func(s string, p int) int {
		if p = l10(s, p); p == -1 {
			return -1
		}
		if p = l20(s, p); p == -1 {
			return -1
		}
		return p
	}
	// [0-9] (CharClass)
	l22 := func(s string, p int) int {
		if len(s) <= p {
			return -1
		}
		rn := s[p]
		switch {
		case rn >= '0' && rn <= '9':
			return p + 1
		}
		return -1
	}
	// [0-9]+ (Plus)
	l23 := func(s string, p int) int {
		if p = l22(s, p); p == -1 {
			return -1
		}
		for len(s) > p {
			if np := l22(s, p); np == -1 {
				return p
			} else {
				p = np
			}
		}
		return p
	}
	// \. (Literal)
	l24 := func(s string, p int) int {
		if p < len(s) && s[p] == '.' {
			return p + 1
		}
		return -1
	}
	// \.? (Quest)
	l25 := func(s string, p int) int {
		if np := l24(s, p); np != -1 {
			return np
		}
		return p
	}
	// [0-9]* (Star)
	l26 := func(s string, p int) int {
		for len(s) > p {
			if np := l22(s, p); np == -1 {
				return p
			} else {
				p = np
			}
		}
		return p
	}
	// [0-9]+\.?[0-9]* (Concat)
	l27 := func(s string, p int) int {
		if p = l23(s, p); p == -1 {
			return -1
		}
		if p = l25(s, p); p == -1 {
			return -1
		}
		if p = l26(s, p); p == -1 {
			return -1
		}
		return p
	}
	// \.[0-9]+ (Concat)
	l28 := func(s string, p int) int {
		if p = l24(s, p); p == -1 {
			return -1
		}
		if p = l23(s, p); p == -1 {
			return -1
		}
		return p
	}
	// [0-9]+\.?[0-9]*|\.[0-9]+ (Alternate)
	l29 := func(s string, p int) int {
		if np := l27(s, p); np != -1 {
			return np
		}
		if np := l28(s, p); np != -1 {
			return np
		}
		return -1
	}
	// (?i:E) (Literal)
	l30 := func(s string, p int) int {
		if p+1 <= len(s) && strings.EqualFold(s[p:p+1], "E") {
			return p + 1
		}
		return -1
	}
	// (?i:E[\+\-]?[0-9]+) (Concat)
	l31 := func(s string, p int) int {
		if p = l30(s, p); p == -1 {
			return -1
		}
		if p = l1(s, p); p == -1 {
			return -1
		}
		if p = l23(s, p); p == -1 {
			return -1
		}
		return p
	}
	// (?i:(?:E[\+\-]?[0-9]+)?) (Quest)
	l32 := func(s string, p int) int {
		if np := l31(s, p); np != -1 {
			return np
		}
		return p
	}
	// (?i:(?:[0-9]+\.?[0-9]*|\.[0-9]+)(?:E[\+\-]?[0-9]+)?) (Concat)
	l33 := func(s string, p int) int {
		if p = l29(s, p); p == -1 {
			return -1
		}
		if p = l32(s, p); p == -1 {
			return -1
		}
		return p
	}
	// (?:[0\\]x|\$)[0-9A-Fa-f]+|0(?:o?[0-7]+|b[01]+)|(?i:(?:[0-9]+\.?[0-9]*|\.[0-9]+)(?:E[\+\-]?[0-9]+)?) (Alternate)
	l34 := func(s string, p int) int {
		if np := l9(s, p); np != -1 {
			return np
		}
		if np := l21(s, p); np != -1 {
			return np
		}
		if np := l33(s, p); np != -1 {
			return np
		}
		return -1
	}
	// [\+\-]?(?:(?:[0\\]x|\$)[0-9A-Fa-f]+|0(?:o?[0-7]+|b[01]+)|(?i:(?:[0-9]+\.?[0-9]*|\.[0-9]+)(?:E[\+\-]?[0-9]+)?)) (Concat)
	l35 := func(s string, p int) int {
		if p = l1(s, p); p == -1 {
			return -1
		}
		if p = l34(s, p); p == -1 {
			return -1
		}
		return p
	}
	np := l35(s, p)
	if np == -1 {
		return
	}
	groups[0] = p
	groups[1] = np
	return
}

// [A-Z_a-z][0-9A-Z_a-z]*
func matchConfigID(s string, p int, backrefs []string) (groups [2]int) {
	// [A-Z_a-z] (CharClass)
	l0 := func(s string, p int) int {
		if len(s) <= p {
			return -1
		}
		rn := s[p]
		switch {
		case rn >= 'A' && rn <= 'Z':
			return p + 1
		case rn == '_':
			return p + 1
		case rn >= 'a' && rn <= 'z':
			return p + 1
		}
		return -1
	}
	// [0-9A-Z_a-z] (CharClass)
	l1 := func(s string, p int) int {
		if len(s) <= p {
			return -1
		}
		rn := s[p]
		switch {
		case rn >= '0' && rn <= '9':
			return p + 1
		case rn >= 'A' && rn <= 'Z':
			return p + 1
		case rn == '_':
			return p + 1
		case rn >= 'a' && rn <= 'z':
			return p + 1
		}
		return -1
	}
	// [0-9A-Z_a-z]* (Star)
	l2 := func(s string, p int) int {
		for len(s) > p {
			if np := l1(s, p); np == -1 {
				return p
			} else {
				p = np
			}
		}
		return p
	}
	// [A-Z_a-z][0-9A-Z_a-z]* (Concat)
	l3 := func(s string, p int) int {
		if p = l0(s, p); p == -1 {
			return -1
		}
		if p = l2(s, p); p == -1 {
			return -1
		}
		return p
	}
	np := l3(s, p)
	if np == -1 {
		return
	}
	groups[0] = p
	groups[1] = np
	return
}

// \}
func matchConfigSC(s string, p int, backrefs []string) (groups [2]int) {
	if p < len(s) && s[p] == '}' {
		groups[0] = p
		groups[1] = p + 1
	}
	return
}

// =
func matchConfigOP(s string, p int, backrefs []string) (groups [2]int) {
	if p < len(s) && s[p] == '=' {
		groups[0] = p
		groups[1] = p + 1
	}
	return
}

// (?-s:\\.|.)
func matchConfigEX(s string, p int, backrefs []string) (groups [2]int) {
	// \\ (Literal)
	l0 := func(s string, p int) int {
		if p < len(s) && s[p] == '\\' {
			return p + 1
		}
		return -1
	}
	// (?-s:.) (AnyCharNotNL)
	l1 := func(s string, p int) int {
		var (
			rn rune
			n  int
		)
		if s[p] < utf8.RuneSelf {
			rn, n = rune(s[p]), 1
		} else {
			rn, n = utf8.DecodeRuneInString(s[p:])
		}
		if len(s) <= p+n || rn == '\n' {
			return -1
		}
		return p + n
	}
	// (?-s:\\.) (Concat)
	l2 := func(s string, p int) int {
		if p = l0(s, p); p == -1 {
			return -1
		}
		if p = l1(s, p); p == -1 {
			return -1
		}
		return p
	}
	// (?-s:\\.|.) (Alternate)
	l3 := func(s string, p int) int {
		if np := l2(s, p); np != -1 {
			return np
		}
		if np := l1(s, p); np != -1 {
			return np
		}
		return -1
	}
	np := l3(s, p)
	if np == -1 {
		return
	}
	groups[0] = p
	groups[1] = np
	return
}
