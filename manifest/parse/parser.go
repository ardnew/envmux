// Code generated by peg --inline --strict --output ./parser.go ./internal/grammar.peg. DO NOT EDIT.

package parse

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"slices"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleSpec
	ruleNamespaceSpec
	ruleNamespaceName
	ruleNamespaceCapture
	ruleCompositeSpec
	ruleCompositeList
	ruleCompositePair
	ruleCompositeCapture
	ruleCompositeMeta
	ruleCompositeArgs
	ruleArgumentCapture
	ruleParameterSpec
	ruleParameterList
	ruleParameterItem
	ruleParameterCapture
	ruleStatementSpec
	ruleStatementList
	ruleStatementAssn
	ruleStatementEval
	ruleStatementAtom
	ruleStatementExpr
	ruleStatementCapture
	ruleEndOfLine
	ruleEndOfFile
	ruleLineComment
	ruleBlockComment
	ruleBlank
	ruleSpace
	ruleElide
	rule_
	rule___
	ruleIdentifier
	ruleCommonWord
	ruleCommonName
	ruleBinLiteral
	ruleOctLiteral
	ruleDecLiteral
	ruleHexLiteral
	ruleRational
	ruleExponent
	ruleIntLiteral
	ruleFltLiteral
	ruleNumLiteral
	ruleOctEscape
	ruleHexEscape
	ruleSeqEscape
	ruleStrLiteral
	ruleInitCompositeMeta
	ruleTermCompositeMeta
	ruleInitParameterMeta
	ruleTermParameterMeta
	ruleInitStatementMeta
	ruleTermStatementMeta
	ruleAssnStatementMeta
	ruleSeqDelim
	ruleSetDelim
	ruleSIGN_SYMBOL
	ruleDEC_NONZERO
	ruleDEC_DIGIT
	ruleBIN_DIGIT
	ruleOCT_HIBITS
	ruleOCT_DIGIT
	ruleHEX_DIGIT
	ruleBIN_SIGIL
	ruleOCT_SIGIL
	ruleHEX_SIGIL
	ruleEXP_SIGIL
	ruleBIN_PREFIX
	ruleHEX_PREFIX
	ruleIDENT_ALPHA
	ruleIDENT_ALNUM
	ruleMETA_SYNTAX
	ruleLF
	ruleCR
	ruleTAB
	ruleSP
	ruleSEMI
	ruleCOMMA
	ruleHASH
	ruleDQUOTE
	ruleSTAR
	ruleSLASH
	ruleEQUALS
	ruleLANGLE
	ruleRANGLE
	ruleLPAREN
	ruleRPAREN
	ruleLBRACE
	ruleRBRACE
	ruleAction0
	rulePegText
	ruleAction1
	ruleAction2
	ruleAction3
	ruleAction4
	ruleAction5
)

var rul3s = [...]string{
	"Unknown",
	"Spec",
	"NamespaceSpec",
	"NamespaceName",
	"NamespaceCapture",
	"CompositeSpec",
	"CompositeList",
	"CompositePair",
	"CompositeCapture",
	"CompositeMeta",
	"CompositeArgs",
	"ArgumentCapture",
	"ParameterSpec",
	"ParameterList",
	"ParameterItem",
	"ParameterCapture",
	"StatementSpec",
	"StatementList",
	"StatementAssn",
	"StatementEval",
	"StatementAtom",
	"StatementExpr",
	"StatementCapture",
	"EndOfLine",
	"EndOfFile",
	"LineComment",
	"BlockComment",
	"Blank",
	"Space",
	"Elide",
	"_",
	"___",
	"Identifier",
	"CommonWord",
	"CommonName",
	"BinLiteral",
	"OctLiteral",
	"DecLiteral",
	"HexLiteral",
	"Rational",
	"Exponent",
	"IntLiteral",
	"FltLiteral",
	"NumLiteral",
	"OctEscape",
	"HexEscape",
	"SeqEscape",
	"StrLiteral",
	"InitCompositeMeta",
	"TermCompositeMeta",
	"InitParameterMeta",
	"TermParameterMeta",
	"InitStatementMeta",
	"TermStatementMeta",
	"AssnStatementMeta",
	"SeqDelim",
	"SetDelim",
	"SIGN_SYMBOL",
	"DEC_NONZERO",
	"DEC_DIGIT",
	"BIN_DIGIT",
	"OCT_HIBITS",
	"OCT_DIGIT",
	"HEX_DIGIT",
	"BIN_SIGIL",
	"OCT_SIGIL",
	"HEX_SIGIL",
	"EXP_SIGIL",
	"BIN_PREFIX",
	"HEX_PREFIX",
	"IDENT_ALPHA",
	"IDENT_ALNUM",
	"META_SYNTAX",
	"LF",
	"CR",
	"TAB",
	"SP",
	"SEMI",
	"COMMA",
	"HASH",
	"DQUOTE",
	"STAR",
	"SLASH",
	"EQUALS",
	"LANGLE",
	"RANGLE",
	"LPAREN",
	"RPAREN",
	"LBRACE",
	"RBRACE",
	"Action0",
	"PegText",
	"Action1",
	"Action2",
	"Action3",
	"Action4",
	"Action5",
}

type Uint interface {
	~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64
}

type token[U Uint] struct {
	pegRule
	begin, end U
}

func (t *token[_]) String() string {
	// \x1B[34m = blue
	// \x1B[m   = normal (disable color)
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node[U Uint] struct {
	token[U]
	up, next *node[U]
}

func (n *node[U]) print(w io.Writer, pretty bool, buffer string) {
	var printFunc func(n *node[U], depth int)
	printFunc = func(n *node[U], depth int) {
		for n != nil {
			for range depth {
				fmt.Fprint(w, " ")
			}
			rule := rul3s[n.pegRule]
			quote := strconv.Quote(string([]rune(buffer)[n.begin:n.end]))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if n.up != nil {
				print(n.up, depth+1)
			}
			n = n.next
		}
	}
	printFunc(n, 0)
}

func (n *node[_]) Print(w io.Writer, buffer string) {
	n.print(w, false, buffer)
}

func (n *node[_]) PrettyPrint(w io.Writer, buffer string) {
	n.print(w, true, buffer)
}

type tokens[U Uint] struct {
	tree []token[U]
}

func (t *tokens[_]) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens[_]) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens[U]) AST() *node[U] {
	type element struct {
		node *node[U]
		down *element
	}
	tokenSlice := t.Tokens()
	var stack *element
	for _, token := range tokenSlice {
		if token.begin == token.end {
			continue
		}
		node := &node[U]{token: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens[_]) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens[_]) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens[_]) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens[U]) Add(rule pegRule, begin, end, index U) {
	tree, i := t.tree, int(index)
	newToken := token[U]{pegRule: rule, begin: begin, end: end}

	if i >= len(tree) {
		t.tree = append(tree, newToken)
		return
	}
	tree[i] = newToken
}

func (t *tokens[U]) Tokens() []token[U] {
	return t.tree
}

type parser[U Uint] struct {
	Namespaces []Namespace

	idx int

	Buffer         string
	buffer         []rune
	rules          [97]func() bool
	parse          func(rule ...int) error
	reset          func()
	Pretty         bool
	disableMemoize bool
	tokens[U]
}

func (p *parser[_]) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *parser[_]) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length := len(positions)
	translations := make(textPositionMap, length)
	posIdx := 0
	line := 1
	symbol := 0

	slices.Sort(positions)

	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[posIdx] {
			translations[positions[posIdx]] = textPosition{line, symbol}
			for posIdx++; posIdx < length; posIdx++ {
				if i == positions[posIdx] {
					return translations
				}
			}
		}
		if posIdx >= length {
			break
		}
	}

	return translations
}

type parseError[U Uint] struct {
	p        *parser[U]
	maxToken token[U]
}

func (e *parseError[U]) Error() string {
	tokenSlice, err := []token[U]{e.maxToken}, "\n"
	positions, p := make([]int, 2*len(tokenSlice)), 0
	for _, t := range tokenSlice {
		positions[p], p = int(t.begin), p+1
		positions[p], p = int(t.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, t := range tokenSlice {
		begin, end := int(t.begin), int(t.end)
		err += fmt.Sprintf(format,
			rul3s[t.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *parser[_]) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens.PrintSyntaxTree(p.Buffer)
	}
}

func (p *parser[_]) WriteSyntaxTree(w io.Writer) {
	p.tokens.WriteSyntaxTree(w, p.Buffer)
}

func (p *parser[_]) SprintSyntaxTree() string {
	var b bytes.Buffer
	p.WriteSyntaxTree(&b)
	return b.String()
}

func (p *parser[_]) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, t := range p.Tokens() {
		switch t.pegRule {

		case rulePegText:
			begin, end = int(t.begin), int(t.end)
			text = string(_buffer[begin:end])

		case ruleAction0:
			p.idx = len(p.Namespaces)
		case ruleAction1:

			p.Namespaces = append(
				p.Namespaces, Namespace{Ident: text},
			)

		case ruleAction2:

			p.Namespaces[p.idx].Composites = append(
				p.Namespaces[p.idx].Composites, Composite{Ident: text},
			)

		case ruleAction3:

			idx := len(p.Namespaces[p.idx].Composites) - 1
			p.Namespaces[p.idx].Composites[idx].Parameters = append(
				p.Namespaces[p.idx].Composites[idx].Parameters, Parameter{Value: text},
			)

		case ruleAction4:

			p.Namespaces[p.idx].Parameters = append(
				p.Namespaces[p.idx].Parameters, Parameter{Value: text},
			)

		case ruleAction5:

			ident, expr, _ := strings.Cut(text, "=")
			p.Namespaces[p.idx].Statements = append(
				p.Namespaces[p.idx].Statements,
				Statement{
					Ident:      strings.TrimSpace(ident),
					Operator:   "=",
					Expression: &Expression{Src: strings.TrimSpace(expr)},
				},
			)

		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty[U Uint](pretty bool) func(*parser[U]) error {
	return func(p *parser[U]) error {
		p.Pretty = pretty
		return nil
	}
}

func Size[U Uint](size int) func(*parser[U]) error {
	return func(p *parser[U]) error {
		p.tokens = tokens[U]{tree: make([]token[U], 0, size)}
		return nil
	}
}

func DisableMemoize[U Uint]() func(*parser[U]) error {
	return func(p *parser[U]) error {
		p.disableMemoize = true
		return nil
	}
}

type memo[U Uint] struct {
	Matched bool
	Partial []token[U]
}

type memoKey[U Uint] struct {
	Rule     U
	Position U
}

func (p *parser[U]) Init(options ...func(*parser[U]) error) error {
	var (
		maxToken             token[U]
		position, tokenIndex U
		buffer               []rune
		memoization          map[memoKey[U]]memo[U]
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		maxToken = token[U]{}
		position, tokenIndex = 0, 0
		memoization = make(map[memoKey[U]]memo[U])
		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens = tree
		if matches {
			p.Trim(uint32(tokenIndex))
			return nil
		}
		return &parseError[U]{p, maxToken}
	}

	add := func(rule pegRule, begin U) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > maxToken.end {
			maxToken = token[U]{rule, begin, position}
		}
	}

	memoize := func(rule U, begin U, tokenIndexStart U, matched bool) {
		if p.disableMemoize {
			return
		}
		key := memoKey[U]{rule, begin}
		if !matched {
			memoization[key] = memo[U]{Matched: false}
		} else {
			memoization[key] = memo[U]{
				Matched: true,
				Partial: slices.Clone(tree.tree[tokenIndexStart:tokenIndex]),
			}
		}
	}

	memoizedResult := func(m memo[U]) bool {
		if !m.Matched {
			return false
		}
		tree.tree = append(tree.tree[:tokenIndex], m.Partial...)
		tokenIndex += U(len(m.Partial))
		position = m.Partial[len(m.Partial)-1].end
		if tree.tree[tokenIndex-1].begin != position && position > maxToken.end {
			maxToken = tree.tree[tokenIndex-1]
		}
		return true
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	_rules = [...]func() bool{
		nil,

		/* 0 Spec <- <(___ (NamespaceSpec Action0 ___)* EndOfFile)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{0, position}]; ok {
				return memoizedResult(memoized)
			}
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if !_rules[rule___]() {
					goto l0
				}
			l2:
				{
					position3, tokenIndex3 := position, tokenIndex
					{
						position4 := position
						{
							position5 := position
							{
								position6 := position
								if !_rules[ruleNamespaceName]() {
									goto l3
								}
								add(rulePegText, position6)
							}
							{
								add(ruleAction1, position)
							}
							add(ruleNamespaceCapture, position5)
						}
						{
							position8, tokenIndex8 := position, tokenIndex
							{
								position10 := position
								{
									position11 := position
									if !_rules[rule___]() {
										goto l8
									}
									if !_rules[ruleLANGLE]() {
										goto l8
									}
									if !_rules[rule___]() {
										goto l8
									}
									add(ruleInitCompositeMeta, position11)
								}
							l12:
								{
									position13, tokenIndex13 := position, tokenIndex
									{
										position14 := position
										{
											position15, tokenIndex15 := position, tokenIndex
											if !_rules[ruleSeqDelim]() {
												goto l16
											}
											goto l15
										l16:
											position, tokenIndex = position15, tokenIndex15
											if !_rules[ruleCompositePair]() {
												goto l13
											}
										l17:
											{
												position18, tokenIndex18 := position, tokenIndex
												if !_rules[ruleSeqDelim]() {
													goto l18
												}
												if !_rules[ruleCompositePair]() {
													goto l18
												}
												goto l17
											l18:
												position, tokenIndex = position18, tokenIndex18
											}
										}
									l15:
										add(ruleCompositeList, position14)
									}
									goto l12
								l13:
									position, tokenIndex = position13, tokenIndex13
								}
								{
									position19 := position
									if !_rules[rule___]() {
										goto l8
									}
									if !_rules[ruleRANGLE]() {
										goto l8
									}
									if !_rules[rule___]() {
										goto l8
									}
									add(ruleTermCompositeMeta, position19)
								}
								add(ruleCompositeSpec, position10)
							}
							goto l9
						l8:
							position, tokenIndex = position8, tokenIndex8
						}
					l9:
						{
							position20, tokenIndex20 := position, tokenIndex
							{
								position22 := position
								if !_rules[ruleInitParameterMeta]() {
									goto l20
								}
							l23:
								{
									position24, tokenIndex24 := position, tokenIndex
									{
										position25 := position
										{
											position26, tokenIndex26 := position, tokenIndex
											if !_rules[ruleSeqDelim]() {
												goto l27
											}
											goto l26
										l27:
											position, tokenIndex = position26, tokenIndex26
											if !_rules[ruleParameterCapture]() {
												goto l24
											}
										l28:
											{
												position29, tokenIndex29 := position, tokenIndex
												if !_rules[ruleSeqDelim]() {
													goto l29
												}
												if !_rules[ruleParameterCapture]() {
													goto l29
												}
												goto l28
											l29:
												position, tokenIndex = position29, tokenIndex29
											}
										}
									l26:
										add(ruleParameterList, position25)
									}
									goto l23
								l24:
									position, tokenIndex = position24, tokenIndex24
								}
								if !_rules[ruleTermParameterMeta]() {
									goto l20
								}
								add(ruleParameterSpec, position22)
							}
							goto l21
						l20:
							position, tokenIndex = position20, tokenIndex20
						}
					l21:
						{
							position30, tokenIndex30 := position, tokenIndex
							{
								position32 := position
								if !_rules[ruleInitStatementMeta]() {
									goto l30
								}
							l33:
								{
									position34, tokenIndex34 := position, tokenIndex
									{
										position35 := position
										{
											position36, tokenIndex36 := position, tokenIndex
											if !_rules[ruleSetDelim]() {
												goto l37
											}
											goto l36
										l37:
											position, tokenIndex = position36, tokenIndex36
											if !_rules[ruleStatementCapture]() {
												goto l34
											}
										l38:
											{
												position39, tokenIndex39 := position, tokenIndex
												if !_rules[ruleSetDelim]() {
													goto l39
												}
												if !_rules[ruleStatementCapture]() {
													goto l39
												}
												goto l38
											l39:
												position, tokenIndex = position39, tokenIndex39
											}
										}
									l36:
										add(ruleStatementList, position35)
									}
									goto l33
								l34:
									position, tokenIndex = position34, tokenIndex34
								}
								if !_rules[ruleTermStatementMeta]() {
									goto l30
								}
								add(ruleStatementSpec, position32)
							}
							goto l31
						l30:
							position, tokenIndex = position30, tokenIndex30
						}
					l31:
						add(ruleNamespaceSpec, position4)
					}
					{
						add(ruleAction0, position)
					}
					if !_rules[rule___]() {
						goto l3
					}
					goto l2
				l3:
					position, tokenIndex = position3, tokenIndex3
				}
				{
					position41 := position
					{
						position42, tokenIndex42 := position, tokenIndex
						if !matchDot() {
							goto l42
						}
						goto l0
					l42:
						position, tokenIndex = position42, tokenIndex42
					}
					add(ruleEndOfFile, position41)
				}
				add(ruleSpec, position1)
			}
			memoize(0, position0, tokenIndex0, true)
			return true
		l0:
			memoize(0, position0, tokenIndex0, false)
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 NamespaceSpec <- <(NamespaceCapture CompositeSpec? ParameterSpec? StatementSpec?)> */
		nil,
		/* 2 NamespaceName <- <CommonName> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{2, position}]; ok {
				return memoizedResult(memoized)
			}
			position44, tokenIndex44 := position, tokenIndex
			{
				position45 := position
				{
					position46 := position
					if !_rules[ruleIdentifier]() {
						goto l44
					}
				l47:
					{
						position48, tokenIndex48 := position, tokenIndex
						if !_rules[ruleCommonWord]() {
							goto l48
						}
						goto l47
					l48:
						position, tokenIndex = position48, tokenIndex48
					}
				l49:
					{
						position50, tokenIndex50 := position, tokenIndex
						{
							position51 := position
							if !_rules[ruleBlank]() {
								goto l50
							}
						l52:
							{
								position53, tokenIndex53 := position, tokenIndex
								if !_rules[ruleBlank]() {
									goto l53
								}
								goto l52
							l53:
								position, tokenIndex = position53, tokenIndex53
							}
							add(rule_, position51)
						}
						if !_rules[ruleCommonWord]() {
							goto l50
						}
					l54:
						{
							position55, tokenIndex55 := position, tokenIndex
							if !_rules[ruleCommonWord]() {
								goto l55
							}
							goto l54
						l55:
							position, tokenIndex = position55, tokenIndex55
						}
						goto l49
					l50:
						position, tokenIndex = position50, tokenIndex50
					}
					add(ruleCommonName, position46)
				}
				add(ruleNamespaceName, position45)
			}
			memoize(2, position44, tokenIndex44, true)
			return true
		l44:
			memoize(2, position44, tokenIndex44, false)
			position, tokenIndex = position44, tokenIndex44
			return false
		},
		/* 3 NamespaceCapture <- <(<NamespaceName> Action1)> */
		nil,
		/* 4 CompositeSpec <- <(InitCompositeMeta CompositeList* TermCompositeMeta)> */
		nil,
		/* 5 CompositeList <- <(SeqDelim / (CompositePair (SeqDelim CompositePair)*))> */
		nil,
		/* 6 CompositePair <- <(CompositeCapture CompositeMeta?)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{6, position}]; ok {
				return memoizedResult(memoized)
			}
			position59, tokenIndex59 := position, tokenIndex
			{
				position60 := position
				{
					position61 := position
					{
						position62 := position
						if !_rules[ruleNamespaceName]() {
							goto l59
						}
						add(rulePegText, position62)
					}
					{
						add(ruleAction2, position)
					}
					add(ruleCompositeCapture, position61)
				}
				{
					position64, tokenIndex64 := position, tokenIndex
					{
						position66 := position
						if !_rules[ruleInitParameterMeta]() {
							goto l64
						}
					l67:
						{
							position68, tokenIndex68 := position, tokenIndex
							{
								position69 := position
								{
									position70, tokenIndex70 := position, tokenIndex
									if !_rules[ruleSeqDelim]() {
										goto l71
									}
									goto l70
								l71:
									position, tokenIndex = position70, tokenIndex70
									if !_rules[ruleArgumentCapture]() {
										goto l68
									}
								l72:
									{
										position73, tokenIndex73 := position, tokenIndex
										if !_rules[ruleSeqDelim]() {
											goto l73
										}
										if !_rules[ruleArgumentCapture]() {
											goto l73
										}
										goto l72
									l73:
										position, tokenIndex = position73, tokenIndex73
									}
								}
							l70:
								add(ruleCompositeArgs, position69)
							}
							goto l67
						l68:
							position, tokenIndex = position68, tokenIndex68
						}
						if !_rules[ruleTermParameterMeta]() {
							goto l64
						}
						add(ruleCompositeMeta, position66)
					}
					goto l65
				l64:
					position, tokenIndex = position64, tokenIndex64
				}
			l65:
				add(ruleCompositePair, position60)
			}
			memoize(6, position59, tokenIndex59, true)
			return true
		l59:
			memoize(6, position59, tokenIndex59, false)
			position, tokenIndex = position59, tokenIndex59
			return false
		},
		/* 7 CompositeCapture <- <(<NamespaceName> Action2)> */
		nil,
		/* 8 CompositeMeta <- <(InitParameterMeta CompositeArgs* TermParameterMeta)> */
		nil,
		/* 9 CompositeArgs <- <(SeqDelim / (ArgumentCapture (SeqDelim ArgumentCapture)*))> */
		nil,
		/* 10 ArgumentCapture <- <(<ParameterItem> Action3)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{10, position}]; ok {
				return memoizedResult(memoized)
			}
			position77, tokenIndex77 := position, tokenIndex
			{
				position78 := position
				{
					position79 := position
					if !_rules[ruleParameterItem]() {
						goto l77
					}
					add(rulePegText, position79)
				}
				{
					add(ruleAction3, position)
				}
				add(ruleArgumentCapture, position78)
			}
			memoize(10, position77, tokenIndex77, true)
			return true
		l77:
			memoize(10, position77, tokenIndex77, false)
			position, tokenIndex = position77, tokenIndex77
			return false
		},
		/* 11 ParameterSpec <- <(InitParameterMeta ParameterList* TermParameterMeta)> */
		nil,
		/* 12 ParameterList <- <(SeqDelim / (ParameterCapture (SeqDelim ParameterCapture)*))> */
		nil,
		/* 13 ParameterItem <- <(Identifier / NumLiteral / StrLiteral)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{13, position}]; ok {
				return memoizedResult(memoized)
			}
			position83, tokenIndex83 := position, tokenIndex
			{
				position84 := position
				{
					position85, tokenIndex85 := position, tokenIndex
					if !_rules[ruleIdentifier]() {
						goto l86
					}
					goto l85
				l86:
					position, tokenIndex = position85, tokenIndex85
					{
						position88 := position
						{
							position89, tokenIndex89 := position, tokenIndex
							if !_rules[ruleSIGN_SYMBOL]() {
								goto l89
							}
							goto l90
						l89:
							position, tokenIndex = position89, tokenIndex89
						}
					l90:
						{
							position91, tokenIndex91 := position, tokenIndex
							{
								position93 := position
								{
									position94, tokenIndex94 := position, tokenIndex
									{
										position96 := position
										{
											position97, tokenIndex97 := position, tokenIndex
										l99:
											{
												position100, tokenIndex100 := position, tokenIndex
												if !_rules[ruleDEC_DIGIT]() {
													goto l100
												}
												goto l99
											l100:
												position, tokenIndex = position100, tokenIndex100
											}
											if buffer[position] != '.' {
												goto l98
											}
											position++
											if !_rules[ruleDEC_DIGIT]() {
												goto l98
											}
										l101:
											{
												position102, tokenIndex102 := position, tokenIndex
												if !_rules[ruleDEC_DIGIT]() {
													goto l102
												}
												goto l101
											l102:
												position, tokenIndex = position102, tokenIndex102
											}
											goto l97
										l98:
											position, tokenIndex = position97, tokenIndex97
											if !_rules[ruleDEC_DIGIT]() {
												goto l95
											}
										l103:
											{
												position104, tokenIndex104 := position, tokenIndex
												if !_rules[ruleDEC_DIGIT]() {
													goto l104
												}
												goto l103
											l104:
												position, tokenIndex = position104, tokenIndex104
											}
											if buffer[position] != '.' {
												goto l95
											}
											position++
										}
									l97:
										add(ruleRational, position96)
									}
									{
										position105, tokenIndex105 := position, tokenIndex
										if !_rules[ruleExponent]() {
											goto l105
										}
										goto l106
									l105:
										position, tokenIndex = position105, tokenIndex105
									}
								l106:
									goto l94
								l95:
									position, tokenIndex = position94, tokenIndex94
									if c := buffer[position]; c < '0' || c > '9' {
										goto l92
									}
									position++
								l107:
									{
										position108, tokenIndex108 := position, tokenIndex
										if c := buffer[position]; c < '0' || c > '9' {
											goto l108
										}
										position++
										goto l107
									l108:
										position, tokenIndex = position108, tokenIndex108
									}
									if !_rules[ruleExponent]() {
										goto l92
									}
								}
							l94:
								add(ruleFltLiteral, position93)
							}
							goto l91
						l92:
							position, tokenIndex = position91, tokenIndex91
							{
								position109 := position
								{
									position110, tokenIndex110 := position, tokenIndex
									{
										position112 := position
										{
											position113 := position
											if c := buffer[position]; c < '1' || c > '9' {
												goto l111
											}
											position++
											add(ruleDEC_NONZERO, position113)
										}
									l114:
										{
											position115, tokenIndex115 := position, tokenIndex
											if !_rules[ruleDEC_DIGIT]() {
												goto l115
											}
											goto l114
										l115:
											position, tokenIndex = position115, tokenIndex115
										}
										add(ruleDecLiteral, position112)
									}
									goto l110
								l111:
									position, tokenIndex = position110, tokenIndex110
									{
										position117 := position
										{
											position118 := position
											if buffer[position] != '0' {
												goto l116
											}
											position++
											{
												position119 := position
												if buffer[position] != 'b' {
													goto l116
												}
												position++
												add(ruleBIN_SIGIL, position119)
											}
											add(ruleBIN_PREFIX, position118)
										}
										{
											position122 := position
											{
												position123, tokenIndex123 := position, tokenIndex
												if buffer[position] != '0' {
													goto l124
												}
												position++
												goto l123
											l124:
												position, tokenIndex = position123, tokenIndex123
												if buffer[position] != '1' {
													goto l116
												}
												position++
											}
										l123:
											add(ruleBIN_DIGIT, position122)
										}
									l120:
										{
											position121, tokenIndex121 := position, tokenIndex
											{
												position125 := position
												{
													position126, tokenIndex126 := position, tokenIndex
													if buffer[position] != '0' {
														goto l127
													}
													position++
													goto l126
												l127:
													position, tokenIndex = position126, tokenIndex126
													if buffer[position] != '1' {
														goto l121
													}
													position++
												}
											l126:
												add(ruleBIN_DIGIT, position125)
											}
											goto l120
										l121:
											position, tokenIndex = position121, tokenIndex121
										}
										add(ruleBinLiteral, position117)
									}
									goto l110
								l116:
									position, tokenIndex = position110, tokenIndex110
									{
										position129 := position
										{
											position130 := position
											if buffer[position] != '0' {
												goto l128
											}
											position++
											if !_rules[ruleHEX_SIGIL]() {
												goto l128
											}
											add(ruleHEX_PREFIX, position130)
										}
										if !_rules[ruleHEX_DIGIT]() {
											goto l128
										}
									l131:
										{
											position132, tokenIndex132 := position, tokenIndex
											if !_rules[ruleHEX_DIGIT]() {
												goto l132
											}
											goto l131
										l132:
											position, tokenIndex = position132, tokenIndex132
										}
										add(ruleHexLiteral, position129)
									}
									goto l110
								l128:
									position, tokenIndex = position110, tokenIndex110
									{
										position133 := position
										if buffer[position] != '0' {
											goto l87
										}
										position++
										{
											position134, tokenIndex134 := position, tokenIndex
											{
												position136, tokenIndex136 := position, tokenIndex
												{
													position138 := position
													if buffer[position] != 'o' {
														goto l136
													}
													position++
													add(ruleOCT_SIGIL, position138)
												}
												goto l137
											l136:
												position, tokenIndex = position136, tokenIndex136
											}
										l137:
											if !_rules[ruleOCT_DIGIT]() {
												goto l134
											}
										l139:
											{
												position140, tokenIndex140 := position, tokenIndex
												if !_rules[ruleOCT_DIGIT]() {
													goto l140
												}
												goto l139
											l140:
												position, tokenIndex = position140, tokenIndex140
											}
											goto l135
										l134:
											position, tokenIndex = position134, tokenIndex134
										}
									l135:
										add(ruleOctLiteral, position133)
									}
								}
							l110:
								add(ruleIntLiteral, position109)
							}
						}
					l91:
						add(ruleNumLiteral, position88)
					}
					goto l85
				l87:
					position, tokenIndex = position85, tokenIndex85
					{
						position141 := position
						if !_rules[ruleDQUOTE]() {
							goto l83
						}
					l142:
						{
							position143, tokenIndex143 := position, tokenIndex
							{
								position144, tokenIndex144 := position, tokenIndex
								{
									position146 := position
									{
										position147, tokenIndex147 := position, tokenIndex
										if buffer[position] != '\\' {
											goto l148
										}
										position++
										{
											position149, tokenIndex149 := position, tokenIndex
											if buffer[position] != 'a' {
												goto l150
											}
											position++
											goto l149
										l150:
											position, tokenIndex = position149, tokenIndex149
											if buffer[position] != 'b' {
												goto l151
											}
											position++
											goto l149
										l151:
											position, tokenIndex = position149, tokenIndex149
											if buffer[position] != 'e' {
												goto l152
											}
											position++
											goto l149
										l152:
											position, tokenIndex = position149, tokenIndex149
											if buffer[position] != 'f' {
												goto l153
											}
											position++
											goto l149
										l153:
											position, tokenIndex = position149, tokenIndex149
											if buffer[position] != 'n' {
												goto l154
											}
											position++
											goto l149
										l154:
											position, tokenIndex = position149, tokenIndex149
											if buffer[position] != 'r' {
												goto l155
											}
											position++
											goto l149
										l155:
											position, tokenIndex = position149, tokenIndex149
											if buffer[position] != 't' {
												goto l156
											}
											position++
											goto l149
										l156:
											position, tokenIndex = position149, tokenIndex149
											if buffer[position] != 'v' {
												goto l157
											}
											position++
											goto l149
										l157:
											position, tokenIndex = position149, tokenIndex149
											if buffer[position] != '"' {
												goto l158
											}
											position++
											goto l149
										l158:
											position, tokenIndex = position149, tokenIndex149
											if buffer[position] != '\\' {
												goto l148
											}
											position++
										}
									l149:
										goto l147
									l148:
										position, tokenIndex = position147, tokenIndex147
										{
											position160 := position
											if buffer[position] != '\\' {
												goto l159
											}
											position++
											if buffer[position] != '0' {
												goto l159
											}
											position++
											{
												position161, tokenIndex161 := position, tokenIndex
												{
													position163 := position
													if c := buffer[position]; c < '0' || c > '3' {
														goto l162
													}
													position++
													add(ruleOCT_HIBITS, position163)
												}
												if !_rules[ruleOCT_DIGIT]() {
													goto l162
												}
												if !_rules[ruleOCT_DIGIT]() {
													goto l162
												}
												goto l161
											l162:
												position, tokenIndex = position161, tokenIndex161
												if !_rules[ruleOCT_DIGIT]() {
													goto l159
												}
												{
													position164, tokenIndex164 := position, tokenIndex
													if !_rules[ruleOCT_DIGIT]() {
														goto l164
													}
													goto l165
												l164:
													position, tokenIndex = position164, tokenIndex164
												}
											l165:
											}
										l161:
											add(ruleOctEscape, position160)
										}
										goto l147
									l159:
										position, tokenIndex = position147, tokenIndex147
										{
											position166 := position
											if buffer[position] != '\\' {
												goto l145
											}
											position++
											if !_rules[ruleHEX_SIGIL]() {
												goto l145
											}
											if !_rules[ruleHEX_DIGIT]() {
												goto l145
											}
											{
												position167, tokenIndex167 := position, tokenIndex
												if !_rules[ruleHEX_DIGIT]() {
													goto l167
												}
												goto l168
											l167:
												position, tokenIndex = position167, tokenIndex167
											}
										l168:
											add(ruleHexEscape, position166)
										}
									}
								l147:
									add(ruleSeqEscape, position146)
								}
								goto l144
							l145:
								position, tokenIndex = position144, tokenIndex144
								{
									position169, tokenIndex169 := position, tokenIndex
									if !_rules[ruleDQUOTE]() {
										goto l169
									}
									goto l143
								l169:
									position, tokenIndex = position169, tokenIndex169
								}
								if !matchDot() {
									goto l143
								}
							}
						l144:
							goto l142
						l143:
							position, tokenIndex = position143, tokenIndex143
						}
						if !_rules[ruleDQUOTE]() {
							goto l83
						}
						add(ruleStrLiteral, position141)
					}
				}
			l85:
				add(ruleParameterItem, position84)
			}
			memoize(13, position83, tokenIndex83, true)
			return true
		l83:
			memoize(13, position83, tokenIndex83, false)
			position, tokenIndex = position83, tokenIndex83
			return false
		},
		/* 14 ParameterCapture <- <(<ParameterItem> Action4)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{14, position}]; ok {
				return memoizedResult(memoized)
			}
			position170, tokenIndex170 := position, tokenIndex
			{
				position171 := position
				{
					position172 := position
					if !_rules[ruleParameterItem]() {
						goto l170
					}
					add(rulePegText, position172)
				}
				{
					add(ruleAction4, position)
				}
				add(ruleParameterCapture, position171)
			}
			memoize(14, position170, tokenIndex170, true)
			return true
		l170:
			memoize(14, position170, tokenIndex170, false)
			position, tokenIndex = position170, tokenIndex170
			return false
		},
		/* 15 StatementSpec <- <(InitStatementMeta StatementList* TermStatementMeta)> */
		nil,
		/* 16 StatementList <- <(SetDelim / (StatementCapture (SetDelim StatementCapture)*))> */
		nil,
		/* 17 StatementAssn <- <(Identifier AssnStatementMeta StatementEval)> */
		nil,
		/* 18 StatementEval <- <(StatementExpr / StatementAtom)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{18, position}]; ok {
				return memoizedResult(memoized)
			}
			position177, tokenIndex177 := position, tokenIndex
			{
				position178 := position
				{
					position179, tokenIndex179 := position, tokenIndex
					{
						position181 := position
						if !_rules[ruleInitStatementMeta]() {
							goto l180
						}
					l182:
						{
							position183, tokenIndex183 := position, tokenIndex
							if !_rules[ruleStatementEval]() {
								goto l183
							}
							goto l182
						l183:
							position, tokenIndex = position183, tokenIndex183
						}
						if !_rules[ruleTermStatementMeta]() {
							goto l180
						}
						add(ruleStatementExpr, position181)
					}
					goto l179
				l180:
					position, tokenIndex = position179, tokenIndex179
					{
						position184 := position
						{
							position187, tokenIndex187 := position, tokenIndex
							if !_rules[ruleSetDelim]() {
								goto l187
							}
							goto l177
						l187:
							position, tokenIndex = position187, tokenIndex187
						}
						{
							position188, tokenIndex188 := position, tokenIndex
							if !_rules[ruleInitStatementMeta]() {
								goto l188
							}
							goto l177
						l188:
							position, tokenIndex = position188, tokenIndex188
						}
						{
							position189, tokenIndex189 := position, tokenIndex
							if !_rules[ruleTermStatementMeta]() {
								goto l189
							}
							goto l177
						l189:
							position, tokenIndex = position189, tokenIndex189
						}
						if !matchDot() {
							goto l177
						}
					l185:
						{
							position186, tokenIndex186 := position, tokenIndex
							{
								position190, tokenIndex190 := position, tokenIndex
								if !_rules[ruleSetDelim]() {
									goto l190
								}
								goto l186
							l190:
								position, tokenIndex = position190, tokenIndex190
							}
							{
								position191, tokenIndex191 := position, tokenIndex
								if !_rules[ruleInitStatementMeta]() {
									goto l191
								}
								goto l186
							l191:
								position, tokenIndex = position191, tokenIndex191
							}
							{
								position192, tokenIndex192 := position, tokenIndex
								if !_rules[ruleTermStatementMeta]() {
									goto l192
								}
								goto l186
							l192:
								position, tokenIndex = position192, tokenIndex192
							}
							if !matchDot() {
								goto l186
							}
							goto l185
						l186:
							position, tokenIndex = position186, tokenIndex186
						}
						add(ruleStatementAtom, position184)
					}
				}
			l179:
				add(ruleStatementEval, position178)
			}
			memoize(18, position177, tokenIndex177, true)
			return true
		l177:
			memoize(18, position177, tokenIndex177, false)
			position, tokenIndex = position177, tokenIndex177
			return false
		},
		/* 19 StatementAtom <- <(!SetDelim !InitStatementMeta !TermStatementMeta .)+> */
		nil,
		/* 20 StatementExpr <- <(InitStatementMeta StatementEval* TermStatementMeta)> */
		nil,
		/* 21 StatementCapture <- <(<StatementAssn> Action5)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{21, position}]; ok {
				return memoizedResult(memoized)
			}
			position195, tokenIndex195 := position, tokenIndex
			{
				position196 := position
				{
					position197 := position
					{
						position198 := position
						if !_rules[ruleIdentifier]() {
							goto l195
						}
						{
							position199 := position
							if !_rules[rule___]() {
								goto l195
							}
							{
								position200 := position
								if buffer[position] != '=' {
									goto l195
								}
								position++
								add(ruleEQUALS, position200)
							}
							if !_rules[rule___]() {
								goto l195
							}
							add(ruleAssnStatementMeta, position199)
						}
						if !_rules[ruleStatementEval]() {
							goto l195
						}
						add(ruleStatementAssn, position198)
					}
					add(rulePegText, position197)
				}
				{
					add(ruleAction5, position)
				}
				add(ruleStatementCapture, position196)
			}
			memoize(21, position195, tokenIndex195, true)
			return true
		l195:
			memoize(21, position195, tokenIndex195, false)
			position, tokenIndex = position195, tokenIndex195
			return false
		},
		/* 22 EndOfLine <- <((CR LF) / LF)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{22, position}]; ok {
				return memoizedResult(memoized)
			}
			position202, tokenIndex202 := position, tokenIndex
			{
				position203 := position
				{
					position204, tokenIndex204 := position, tokenIndex
					if !_rules[ruleCR]() {
						goto l205
					}
					if !_rules[ruleLF]() {
						goto l205
					}
					goto l204
				l205:
					position, tokenIndex = position204, tokenIndex204
					if !_rules[ruleLF]() {
						goto l202
					}
				}
			l204:
				add(ruleEndOfLine, position203)
			}
			memoize(22, position202, tokenIndex202, true)
			return true
		l202:
			memoize(22, position202, tokenIndex202, false)
			position, tokenIndex = position202, tokenIndex202
			return false
		},
		/* 23 EndOfFile <- <!.> */
		nil,
		/* 24 LineComment <- <((HASH / (SLASH SLASH)) (!EndOfLine .)*)> */
		nil,
		/* 25 BlockComment <- <(SLASH STAR (!(STAR SLASH) .)* (STAR SLASH))> */
		nil,
		/* 26 Blank <- <(SP / TAB)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{26, position}]; ok {
				return memoizedResult(memoized)
			}
			position209, tokenIndex209 := position, tokenIndex
			{
				position210 := position
				{
					position211, tokenIndex211 := position, tokenIndex
					{
						position213 := position
						if buffer[position] != ' ' {
							goto l212
						}
						position++
						add(ruleSP, position213)
					}
					goto l211
				l212:
					position, tokenIndex = position211, tokenIndex211
					{
						position214 := position
						if buffer[position] != '\t' {
							goto l209
						}
						position++
						add(ruleTAB, position214)
					}
				}
			l211:
				add(ruleBlank, position210)
			}
			memoize(26, position209, tokenIndex209, true)
			return true
		l209:
			memoize(26, position209, tokenIndex209, false)
			position, tokenIndex = position209, tokenIndex209
			return false
		},
		/* 27 Space <- <(EndOfLine / Blank)> */
		nil,
		/* 28 Elide <- <(Space / BlockComment / LineComment)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{28, position}]; ok {
				return memoizedResult(memoized)
			}
			position216, tokenIndex216 := position, tokenIndex
			{
				position217 := position
				{
					position218, tokenIndex218 := position, tokenIndex
					{
						position220 := position
						{
							position221, tokenIndex221 := position, tokenIndex
							if !_rules[ruleEndOfLine]() {
								goto l222
							}
							goto l221
						l222:
							position, tokenIndex = position221, tokenIndex221
							if !_rules[ruleBlank]() {
								goto l219
							}
						}
					l221:
						add(ruleSpace, position220)
					}
					goto l218
				l219:
					position, tokenIndex = position218, tokenIndex218
					{
						position224 := position
						if !_rules[ruleSLASH]() {
							goto l223
						}
						if !_rules[ruleSTAR]() {
							goto l223
						}
					l225:
						{
							position226, tokenIndex226 := position, tokenIndex
							{
								position227, tokenIndex227 := position, tokenIndex
								if !_rules[ruleSTAR]() {
									goto l227
								}
								if !_rules[ruleSLASH]() {
									goto l227
								}
								goto l226
							l227:
								position, tokenIndex = position227, tokenIndex227
							}
							if !matchDot() {
								goto l226
							}
							goto l225
						l226:
							position, tokenIndex = position226, tokenIndex226
						}
						if !_rules[ruleSTAR]() {
							goto l223
						}
						if !_rules[ruleSLASH]() {
							goto l223
						}
						add(ruleBlockComment, position224)
					}
					goto l218
				l223:
					position, tokenIndex = position218, tokenIndex218
					{
						position228 := position
						{
							position229, tokenIndex229 := position, tokenIndex
							{
								position231 := position
								if buffer[position] != '#' {
									goto l230
								}
								position++
								add(ruleHASH, position231)
							}
							goto l229
						l230:
							position, tokenIndex = position229, tokenIndex229
							if !_rules[ruleSLASH]() {
								goto l216
							}
							if !_rules[ruleSLASH]() {
								goto l216
							}
						}
					l229:
					l232:
						{
							position233, tokenIndex233 := position, tokenIndex
							{
								position234, tokenIndex234 := position, tokenIndex
								if !_rules[ruleEndOfLine]() {
									goto l234
								}
								goto l233
							l234:
								position, tokenIndex = position234, tokenIndex234
							}
							if !matchDot() {
								goto l233
							}
							goto l232
						l233:
							position, tokenIndex = position233, tokenIndex233
						}
						add(ruleLineComment, position228)
					}
				}
			l218:
				add(ruleElide, position217)
			}
			memoize(28, position216, tokenIndex216, true)
			return true
		l216:
			memoize(28, position216, tokenIndex216, false)
			position, tokenIndex = position216, tokenIndex216
			return false
		},
		/* 29 _ <- <Blank+> */
		nil,
		/* 30 ___ <- <Elide*> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{30, position}]; ok {
				return memoizedResult(memoized)
			}
			position236, tokenIndex236 := position, tokenIndex
			{
				position237 := position
			l238:
				{
					position239, tokenIndex239 := position, tokenIndex
					if !_rules[ruleElide]() {
						goto l239
					}
					goto l238
				l239:
					position, tokenIndex = position239, tokenIndex239
				}
				add(rule___, position237)
			}
			memoize(30, position236, tokenIndex236, true)
			return true
		},
		/* 31 Identifier <- <(IDENT_ALPHA IDENT_ALNUM*)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{31, position}]; ok {
				return memoizedResult(memoized)
			}
			position240, tokenIndex240 := position, tokenIndex
			{
				position241 := position
				{
					position242 := position
					{
						position243, tokenIndex243 := position, tokenIndex
						if c := buffer[position]; c < 'a' || c > 'z' {
							goto l244
						}
						position++
						goto l243
					l244:
						position, tokenIndex = position243, tokenIndex243
						if c := buffer[position]; c < 'A' || c > 'Z' {
							goto l245
						}
						position++
						goto l243
					l245:
						position, tokenIndex = position243, tokenIndex243
						if buffer[position] != '_' {
							goto l240
						}
						position++
					}
				l243:
					add(ruleIDENT_ALPHA, position242)
				}
			l246:
				{
					position247, tokenIndex247 := position, tokenIndex
					{
						position248 := position
						{
							position249, tokenIndex249 := position, tokenIndex
							if c := buffer[position]; c < 'a' || c > 'z' {
								goto l250
							}
							position++
							goto l249
						l250:
							position, tokenIndex = position249, tokenIndex249
							if c := buffer[position]; c < 'A' || c > 'Z' {
								goto l251
							}
							position++
							goto l249
						l251:
							position, tokenIndex = position249, tokenIndex249
							{
								position253, tokenIndex253 := position, tokenIndex
								if c := buffer[position]; c < '0' || c > '9' {
									goto l254
								}
								position++
								goto l253
							l254:
								position, tokenIndex = position253, tokenIndex253
								if c := buffer[position]; c < '0' || c > '9' {
									goto l252
								}
								position++
							}
						l253:
							goto l249
						l252:
							position, tokenIndex = position249, tokenIndex249
							if buffer[position] != '_' {
								goto l247
							}
							position++
						}
					l249:
						add(ruleIDENT_ALNUM, position248)
					}
					goto l246
				l247:
					position, tokenIndex = position247, tokenIndex247
				}
				add(ruleIdentifier, position241)
			}
			memoize(31, position240, tokenIndex240, true)
			return true
		l240:
			memoize(31, position240, tokenIndex240, false)
			position, tokenIndex = position240, tokenIndex240
			return false
		},
		/* 32 CommonWord <- <(!(Elide / META_SYNTAX) .)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{32, position}]; ok {
				return memoizedResult(memoized)
			}
			position255, tokenIndex255 := position, tokenIndex
			{
				position256 := position
				{
					position257, tokenIndex257 := position, tokenIndex
					{
						position258, tokenIndex258 := position, tokenIndex
						if !_rules[ruleElide]() {
							goto l259
						}
						goto l258
					l259:
						position, tokenIndex = position258, tokenIndex258
						{
							position260 := position
							{
								position261, tokenIndex261 := position, tokenIndex
								if !_rules[ruleLANGLE]() {
									goto l262
								}
								goto l261
							l262:
								position, tokenIndex = position261, tokenIndex261
								if !_rules[ruleRANGLE]() {
									goto l263
								}
								goto l261
							l263:
								position, tokenIndex = position261, tokenIndex261
								if !_rules[ruleLPAREN]() {
									goto l264
								}
								goto l261
							l264:
								position, tokenIndex = position261, tokenIndex261
								if !_rules[ruleRPAREN]() {
									goto l265
								}
								goto l261
							l265:
								position, tokenIndex = position261, tokenIndex261
								if !_rules[ruleLBRACE]() {
									goto l266
								}
								goto l261
							l266:
								position, tokenIndex = position261, tokenIndex261
								if !_rules[ruleRBRACE]() {
									goto l267
								}
								goto l261
							l267:
								position, tokenIndex = position261, tokenIndex261
								if !_rules[ruleSEMI]() {
									goto l268
								}
								goto l261
							l268:
								position, tokenIndex = position261, tokenIndex261
								if !_rules[ruleCOMMA]() {
									goto l269
								}
								goto l261
							l269:
								position, tokenIndex = position261, tokenIndex261
								if !_rules[ruleLF]() {
									goto l270
								}
								goto l261
							l270:
								position, tokenIndex = position261, tokenIndex261
								if !_rules[ruleCR]() {
									goto l257
								}
							}
						l261:
							add(ruleMETA_SYNTAX, position260)
						}
					}
				l258:
					goto l255
				l257:
					position, tokenIndex = position257, tokenIndex257
				}
				if !matchDot() {
					goto l255
				}
				add(ruleCommonWord, position256)
			}
			memoize(32, position255, tokenIndex255, true)
			return true
		l255:
			memoize(32, position255, tokenIndex255, false)
			position, tokenIndex = position255, tokenIndex255
			return false
		},
		/* 33 CommonName <- <(Identifier CommonWord* (_ CommonWord+)*)> */
		nil,
		/* 34 BinLiteral <- <(BIN_PREFIX BIN_DIGIT+)> */
		nil,
		/* 35 OctLiteral <- <('0' (OCT_SIGIL? OCT_DIGIT+)?)> */
		nil,
		/* 36 DecLiteral <- <(DEC_NONZERO DEC_DIGIT*)> */
		nil,
		/* 37 HexLiteral <- <(HEX_PREFIX HEX_DIGIT+)> */
		nil,
		/* 38 Rational <- <((DEC_DIGIT* '.' DEC_DIGIT+) / (DEC_DIGIT+ '.'))> */
		nil,
		/* 39 Exponent <- <(EXP_SIGIL SIGN_SYMBOL? DEC_DIGIT+)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{39, position}]; ok {
				return memoizedResult(memoized)
			}
			position277, tokenIndex277 := position, tokenIndex
			{
				position278 := position
				{
					position279 := position
					{
						position280, tokenIndex280 := position, tokenIndex
						if buffer[position] != 'e' {
							goto l281
						}
						position++
						goto l280
					l281:
						position, tokenIndex = position280, tokenIndex280
						if buffer[position] != 'E' {
							goto l277
						}
						position++
					}
				l280:
					add(ruleEXP_SIGIL, position279)
				}
				{
					position282, tokenIndex282 := position, tokenIndex
					if !_rules[ruleSIGN_SYMBOL]() {
						goto l282
					}
					goto l283
				l282:
					position, tokenIndex = position282, tokenIndex282
				}
			l283:
				if !_rules[ruleDEC_DIGIT]() {
					goto l277
				}
			l284:
				{
					position285, tokenIndex285 := position, tokenIndex
					if !_rules[ruleDEC_DIGIT]() {
						goto l285
					}
					goto l284
				l285:
					position, tokenIndex = position285, tokenIndex285
				}
				add(ruleExponent, position278)
			}
			memoize(39, position277, tokenIndex277, true)
			return true
		l277:
			memoize(39, position277, tokenIndex277, false)
			position, tokenIndex = position277, tokenIndex277
			return false
		},
		/* 40 IntLiteral <- <(DecLiteral / BinLiteral / HexLiteral / OctLiteral)> */
		nil,
		/* 41 FltLiteral <- <((Rational Exponent?) / ([0-9]+ Exponent))> */
		nil,
		/* 42 NumLiteral <- <(SIGN_SYMBOL? (FltLiteral / IntLiteral))> */
		nil,
		/* 43 OctEscape <- <('\\' '0' ((OCT_HIBITS OCT_DIGIT OCT_DIGIT) / (OCT_DIGIT OCT_DIGIT?)))> */
		nil,
		/* 44 HexEscape <- <('\\' HEX_SIGIL HEX_DIGIT HEX_DIGIT?)> */
		nil,
		/* 45 SeqEscape <- <(('\\' ('a' / 'b' / 'e' / 'f' / 'n' / 'r' / 't' / 'v' / '"' / '\\')) / OctEscape / HexEscape)> */
		nil,
		/* 46 StrLiteral <- <(DQUOTE (SeqEscape / (!DQUOTE .))* DQUOTE)> */
		nil,
		/* 47 InitCompositeMeta <- <(___ LANGLE ___)> */
		nil,
		/* 48 TermCompositeMeta <- <(___ RANGLE ___)> */
		nil,
		/* 49 InitParameterMeta <- <(___ LPAREN ___)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{49, position}]; ok {
				return memoizedResult(memoized)
			}
			position295, tokenIndex295 := position, tokenIndex
			{
				position296 := position
				if !_rules[rule___]() {
					goto l295
				}
				if !_rules[ruleLPAREN]() {
					goto l295
				}
				if !_rules[rule___]() {
					goto l295
				}
				add(ruleInitParameterMeta, position296)
			}
			memoize(49, position295, tokenIndex295, true)
			return true
		l295:
			memoize(49, position295, tokenIndex295, false)
			position, tokenIndex = position295, tokenIndex295
			return false
		},
		/* 50 TermParameterMeta <- <(___ RPAREN ___)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{50, position}]; ok {
				return memoizedResult(memoized)
			}
			position297, tokenIndex297 := position, tokenIndex
			{
				position298 := position
				if !_rules[rule___]() {
					goto l297
				}
				if !_rules[ruleRPAREN]() {
					goto l297
				}
				if !_rules[rule___]() {
					goto l297
				}
				add(ruleTermParameterMeta, position298)
			}
			memoize(50, position297, tokenIndex297, true)
			return true
		l297:
			memoize(50, position297, tokenIndex297, false)
			position, tokenIndex = position297, tokenIndex297
			return false
		},
		/* 51 InitStatementMeta <- <(___ LBRACE ___)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{51, position}]; ok {
				return memoizedResult(memoized)
			}
			position299, tokenIndex299 := position, tokenIndex
			{
				position300 := position
				if !_rules[rule___]() {
					goto l299
				}
				if !_rules[ruleLBRACE]() {
					goto l299
				}
				if !_rules[rule___]() {
					goto l299
				}
				add(ruleInitStatementMeta, position300)
			}
			memoize(51, position299, tokenIndex299, true)
			return true
		l299:
			memoize(51, position299, tokenIndex299, false)
			position, tokenIndex = position299, tokenIndex299
			return false
		},
		/* 52 TermStatementMeta <- <(___ RBRACE ___)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{52, position}]; ok {
				return memoizedResult(memoized)
			}
			position301, tokenIndex301 := position, tokenIndex
			{
				position302 := position
				if !_rules[rule___]() {
					goto l301
				}
				if !_rules[ruleRBRACE]() {
					goto l301
				}
				if !_rules[rule___]() {
					goto l301
				}
				add(ruleTermStatementMeta, position302)
			}
			memoize(52, position301, tokenIndex301, true)
			return true
		l301:
			memoize(52, position301, tokenIndex301, false)
			position, tokenIndex = position301, tokenIndex301
			return false
		},
		/* 53 AssnStatementMeta <- <(___ EQUALS ___)> */
		nil,
		/* 54 SeqDelim <- <(___ COMMA ___)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{54, position}]; ok {
				return memoizedResult(memoized)
			}
			position304, tokenIndex304 := position, tokenIndex
			{
				position305 := position
				if !_rules[rule___]() {
					goto l304
				}
				if !_rules[ruleCOMMA]() {
					goto l304
				}
				if !_rules[rule___]() {
					goto l304
				}
				add(ruleSeqDelim, position305)
			}
			memoize(54, position304, tokenIndex304, true)
			return true
		l304:
			memoize(54, position304, tokenIndex304, false)
			position, tokenIndex = position304, tokenIndex304
			return false
		},
		/* 55 SetDelim <- <(___ SEMI ___)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{55, position}]; ok {
				return memoizedResult(memoized)
			}
			position306, tokenIndex306 := position, tokenIndex
			{
				position307 := position
				if !_rules[rule___]() {
					goto l306
				}
				if !_rules[ruleSEMI]() {
					goto l306
				}
				if !_rules[rule___]() {
					goto l306
				}
				add(ruleSetDelim, position307)
			}
			memoize(55, position306, tokenIndex306, true)
			return true
		l306:
			memoize(55, position306, tokenIndex306, false)
			position, tokenIndex = position306, tokenIndex306
			return false
		},
		/* 56 SIGN_SYMBOL <- <('+' / '-')> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{56, position}]; ok {
				return memoizedResult(memoized)
			}
			position308, tokenIndex308 := position, tokenIndex
			{
				position309 := position
				{
					position310, tokenIndex310 := position, tokenIndex
					if buffer[position] != '+' {
						goto l311
					}
					position++
					goto l310
				l311:
					position, tokenIndex = position310, tokenIndex310
					if buffer[position] != '-' {
						goto l308
					}
					position++
				}
			l310:
				add(ruleSIGN_SYMBOL, position309)
			}
			memoize(56, position308, tokenIndex308, true)
			return true
		l308:
			memoize(56, position308, tokenIndex308, false)
			position, tokenIndex = position308, tokenIndex308
			return false
		},
		/* 57 DEC_NONZERO <- <[1-9]> */
		nil,
		/* 58 DEC_DIGIT <- <[0-9]> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{58, position}]; ok {
				return memoizedResult(memoized)
			}
			position313, tokenIndex313 := position, tokenIndex
			{
				position314 := position
				if c := buffer[position]; c < '0' || c > '9' {
					goto l313
				}
				position++
				add(ruleDEC_DIGIT, position314)
			}
			memoize(58, position313, tokenIndex313, true)
			return true
		l313:
			memoize(58, position313, tokenIndex313, false)
			position, tokenIndex = position313, tokenIndex313
			return false
		},
		/* 59 BIN_DIGIT <- <('0' / '1')> */
		nil,
		/* 60 OCT_HIBITS <- <[0-3]> */
		nil,
		/* 61 OCT_DIGIT <- <[0-7]> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{61, position}]; ok {
				return memoizedResult(memoized)
			}
			position317, tokenIndex317 := position, tokenIndex
			{
				position318 := position
				if c := buffer[position]; c < '0' || c > '7' {
					goto l317
				}
				position++
				add(ruleOCT_DIGIT, position318)
			}
			memoize(61, position317, tokenIndex317, true)
			return true
		l317:
			memoize(61, position317, tokenIndex317, false)
			position, tokenIndex = position317, tokenIndex317
			return false
		},
		/* 62 HEX_DIGIT <- <([0-9] / [0-9] / ([a-f] / [A-F]))> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{62, position}]; ok {
				return memoizedResult(memoized)
			}
			position319, tokenIndex319 := position, tokenIndex
			{
				position320 := position
				{
					position321, tokenIndex321 := position, tokenIndex
					if c := buffer[position]; c < '0' || c > '9' {
						goto l322
					}
					position++
					goto l321
				l322:
					position, tokenIndex = position321, tokenIndex321
					if c := buffer[position]; c < '0' || c > '9' {
						goto l323
					}
					position++
					goto l321
				l323:
					position, tokenIndex = position321, tokenIndex321
					{
						position324, tokenIndex324 := position, tokenIndex
						if c := buffer[position]; c < 'a' || c > 'f' {
							goto l325
						}
						position++
						goto l324
					l325:
						position, tokenIndex = position324, tokenIndex324
						if c := buffer[position]; c < 'A' || c > 'F' {
							goto l319
						}
						position++
					}
				l324:
				}
			l321:
				add(ruleHEX_DIGIT, position320)
			}
			memoize(62, position319, tokenIndex319, true)
			return true
		l319:
			memoize(62, position319, tokenIndex319, false)
			position, tokenIndex = position319, tokenIndex319
			return false
		},
		/* 63 BIN_SIGIL <- <'b'> */
		nil,
		/* 64 OCT_SIGIL <- <'o'> */
		nil,
		/* 65 HEX_SIGIL <- <'x'> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{65, position}]; ok {
				return memoizedResult(memoized)
			}
			position328, tokenIndex328 := position, tokenIndex
			{
				position329 := position
				if buffer[position] != 'x' {
					goto l328
				}
				position++
				add(ruleHEX_SIGIL, position329)
			}
			memoize(65, position328, tokenIndex328, true)
			return true
		l328:
			memoize(65, position328, tokenIndex328, false)
			position, tokenIndex = position328, tokenIndex328
			return false
		},
		/* 66 EXP_SIGIL <- <('e' / 'E')> */
		nil,
		/* 67 BIN_PREFIX <- <('0' BIN_SIGIL)> */
		nil,
		/* 68 HEX_PREFIX <- <('0' HEX_SIGIL)> */
		nil,
		/* 69 IDENT_ALPHA <- <([a-z] / [A-Z] / '_')> */
		nil,
		/* 70 IDENT_ALNUM <- <([a-z] / [A-Z] / ([0-9] / [0-9]) / '_')> */
		nil,
		/* 71 META_SYNTAX <- <(LANGLE / RANGLE / LPAREN / RPAREN / LBRACE / RBRACE / SEMI / COMMA / LF / CR)> */
		nil,
		/* 72 LF <- <'\n'> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{72, position}]; ok {
				return memoizedResult(memoized)
			}
			position336, tokenIndex336 := position, tokenIndex
			{
				position337 := position
				if buffer[position] != '\n' {
					goto l336
				}
				position++
				add(ruleLF, position337)
			}
			memoize(72, position336, tokenIndex336, true)
			return true
		l336:
			memoize(72, position336, tokenIndex336, false)
			position, tokenIndex = position336, tokenIndex336
			return false
		},
		/* 73 CR <- <'\r'> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{73, position}]; ok {
				return memoizedResult(memoized)
			}
			position338, tokenIndex338 := position, tokenIndex
			{
				position339 := position
				if buffer[position] != '\r' {
					goto l338
				}
				position++
				add(ruleCR, position339)
			}
			memoize(73, position338, tokenIndex338, true)
			return true
		l338:
			memoize(73, position338, tokenIndex338, false)
			position, tokenIndex = position338, tokenIndex338
			return false
		},
		/* 74 TAB <- <'\t'> */
		nil,
		/* 75 SP <- <' '> */
		nil,
		/* 76 SEMI <- <';'> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{76, position}]; ok {
				return memoizedResult(memoized)
			}
			position342, tokenIndex342 := position, tokenIndex
			{
				position343 := position
				if buffer[position] != ';' {
					goto l342
				}
				position++
				add(ruleSEMI, position343)
			}
			memoize(76, position342, tokenIndex342, true)
			return true
		l342:
			memoize(76, position342, tokenIndex342, false)
			position, tokenIndex = position342, tokenIndex342
			return false
		},
		/* 77 COMMA <- <','> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{77, position}]; ok {
				return memoizedResult(memoized)
			}
			position344, tokenIndex344 := position, tokenIndex
			{
				position345 := position
				if buffer[position] != ',' {
					goto l344
				}
				position++
				add(ruleCOMMA, position345)
			}
			memoize(77, position344, tokenIndex344, true)
			return true
		l344:
			memoize(77, position344, tokenIndex344, false)
			position, tokenIndex = position344, tokenIndex344
			return false
		},
		/* 78 HASH <- <'#'> */
		nil,
		/* 79 DQUOTE <- <'"'> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{79, position}]; ok {
				return memoizedResult(memoized)
			}
			position347, tokenIndex347 := position, tokenIndex
			{
				position348 := position
				if buffer[position] != '"' {
					goto l347
				}
				position++
				add(ruleDQUOTE, position348)
			}
			memoize(79, position347, tokenIndex347, true)
			return true
		l347:
			memoize(79, position347, tokenIndex347, false)
			position, tokenIndex = position347, tokenIndex347
			return false
		},
		/* 80 STAR <- <'*'> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{80, position}]; ok {
				return memoizedResult(memoized)
			}
			position349, tokenIndex349 := position, tokenIndex
			{
				position350 := position
				if buffer[position] != '*' {
					goto l349
				}
				position++
				add(ruleSTAR, position350)
			}
			memoize(80, position349, tokenIndex349, true)
			return true
		l349:
			memoize(80, position349, tokenIndex349, false)
			position, tokenIndex = position349, tokenIndex349
			return false
		},
		/* 81 SLASH <- <'/'> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{81, position}]; ok {
				return memoizedResult(memoized)
			}
			position351, tokenIndex351 := position, tokenIndex
			{
				position352 := position
				if buffer[position] != '/' {
					goto l351
				}
				position++
				add(ruleSLASH, position352)
			}
			memoize(81, position351, tokenIndex351, true)
			return true
		l351:
			memoize(81, position351, tokenIndex351, false)
			position, tokenIndex = position351, tokenIndex351
			return false
		},
		/* 82 EQUALS <- <'='> */
		nil,
		/* 83 LANGLE <- <'<'> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{83, position}]; ok {
				return memoizedResult(memoized)
			}
			position354, tokenIndex354 := position, tokenIndex
			{
				position355 := position
				if buffer[position] != '<' {
					goto l354
				}
				position++
				add(ruleLANGLE, position355)
			}
			memoize(83, position354, tokenIndex354, true)
			return true
		l354:
			memoize(83, position354, tokenIndex354, false)
			position, tokenIndex = position354, tokenIndex354
			return false
		},
		/* 84 RANGLE <- <'>'> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{84, position}]; ok {
				return memoizedResult(memoized)
			}
			position356, tokenIndex356 := position, tokenIndex
			{
				position357 := position
				if buffer[position] != '>' {
					goto l356
				}
				position++
				add(ruleRANGLE, position357)
			}
			memoize(84, position356, tokenIndex356, true)
			return true
		l356:
			memoize(84, position356, tokenIndex356, false)
			position, tokenIndex = position356, tokenIndex356
			return false
		},
		/* 85 LPAREN <- <'('> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{85, position}]; ok {
				return memoizedResult(memoized)
			}
			position358, tokenIndex358 := position, tokenIndex
			{
				position359 := position
				if buffer[position] != '(' {
					goto l358
				}
				position++
				add(ruleLPAREN, position359)
			}
			memoize(85, position358, tokenIndex358, true)
			return true
		l358:
			memoize(85, position358, tokenIndex358, false)
			position, tokenIndex = position358, tokenIndex358
			return false
		},
		/* 86 RPAREN <- <')'> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{86, position}]; ok {
				return memoizedResult(memoized)
			}
			position360, tokenIndex360 := position, tokenIndex
			{
				position361 := position
				if buffer[position] != ')' {
					goto l360
				}
				position++
				add(ruleRPAREN, position361)
			}
			memoize(86, position360, tokenIndex360, true)
			return true
		l360:
			memoize(86, position360, tokenIndex360, false)
			position, tokenIndex = position360, tokenIndex360
			return false
		},
		/* 87 LBRACE <- <'{'> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{87, position}]; ok {
				return memoizedResult(memoized)
			}
			position362, tokenIndex362 := position, tokenIndex
			{
				position363 := position
				if buffer[position] != '{' {
					goto l362
				}
				position++
				add(ruleLBRACE, position363)
			}
			memoize(87, position362, tokenIndex362, true)
			return true
		l362:
			memoize(87, position362, tokenIndex362, false)
			position, tokenIndex = position362, tokenIndex362
			return false
		},
		/* 88 RBRACE <- <'}'> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{88, position}]; ok {
				return memoizedResult(memoized)
			}
			position364, tokenIndex364 := position, tokenIndex
			{
				position365 := position
				if buffer[position] != '}' {
					goto l364
				}
				position++
				add(ruleRBRACE, position365)
			}
			memoize(88, position364, tokenIndex364, true)
			return true
		l364:
			memoize(88, position364, tokenIndex364, false)
			position, tokenIndex = position364, tokenIndex364
			return false
		},
		/* 90 Action0 <- <{ p.idx = len(p.Namespaces) }> */
		nil,
		nil,
		/* 92 Action1 <- <{
		  p.Namespaces = append(
		    p.Namespaces, Namespace{Ident: text},
		  )
		}> */
		nil,
		/* 93 Action2 <- <{
		  p.Namespaces[p.idx].Composites = append(
		    p.Namespaces[p.idx].Composites, Composite{Ident: text},
		  )
		}> */
		nil,
		/* 94 Action3 <- <{
		  idx := len(p.Namespaces[p.idx].Composites) - 1
		  p.Namespaces[p.idx].Composites[idx].Parameters = append(
		    p.Namespaces[p.idx].Composites[idx].Parameters, Parameter{Value: text},
		  )
		}> */
		nil,
		/* 95 Action4 <- <{
		  p.Namespaces[p.idx].Parameters = append(
		    p.Namespaces[p.idx].Parameters, Parameter{Value: text},
		  )
		}> */
		nil,
		/* 96 Action5 <- <{
		  ident, expr, _ := strings.Cut(text, "=")
		  p.Namespaces[p.idx].Statements = append(
		    p.Namespaces[p.idx].Statements,
		    Statement{
		      Ident: strings.TrimSpace(ident),
		      Operator: "=",
		      Expression: &Expression{Src: strings.TrimSpace(expr)},
		    },
		  )
		}> */
		nil,
	}
	p.rules = _rules
	return nil
}
